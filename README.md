# Проект 1
## Построить витрину для RFM-анализа
### Описание первой части проекта (task1)
Задача для компании, которая разрабатывает приложения по доставке еды.

Необходимо составить витрину для RFM-классификации пользователей.

RFM (англ. Recency Frequency Monetary Value — давность, частота, деньги) — сегментация клиентов в анализе сбыта по лояльности.

Определяет три группы:

Recency (давность) — давность с момента последнего заказа.
Frequency (частота) — количество заказов.
Monetary Value (деньги) — сумма затрат клиента.
Каждому клиенту присваивается сегмент - число от 1 до 5 - по каждому из трех измерений. При этом границы необходимо подобрать таким образом, чтобы количество клиентов в каждом сегменте было одинаковым.

Например, если в базе всего 100 клиентов, то 20 клиентов должны получить “1”, 20 клиентов должны получить “2” и т.д.

Для Frequency и Monetary Value клиенты располагаются по возрастанию. Т.е. клиенты с наименьшим количеством заказов получат “1” по шкале frequency. Аналогично, клиенты с наименьшей суммой трат получат “1” по шкале monetary value.

Шкала recency меряется по последнему заказу клиента. “1” получат те, кто не делал заказов а так же те, кто делал заказы давно. “5” получат клиенты, делавшие заказы позже остальных, т.е. относительно недавно

### Требования
Витрина должна располагаться в схеме analysis;

Набор полей: 
user_id, 
recency (число от 1 до 5), 
frequency (число от 1 до 5), 
monetary_value (число от 1 до 5);

В витрине нужны данные с начала 2021 года;

Название витрины - dm_rfm_segments;

Обновления не нужны;

Успешно выполненный заказ - это заказ со статусом 'Closed'

### Результат
С учетом всех требований в схеме analysis создана витрина dm_rfm_segments.
Алгоритм формирования витрины - src/task1

## Доработка представления analysis.orders
### Описание второй части проекта (task2)
Бэкенд-разработчики приложения обновили структуру данных в схеме production: в таблице Orders больше нет поля статуса. А это поле необходимо, потому что для анализа нужно выбрать только успешно выполненные заказы со статусом 'Closed'.
Вместо поля с одним статусом разработчики добавили таблицу для журналирования всех изменений статусов заказов — production.OrderStatusLog

### Требования
Необходимо внести изменения в логику формирования представления analysis.orders: вернуть в него поле status. Значение в этом поле должно соответствовать последнему по времени статусу из таблицы production.OrderStatusLog.

### Результат
Доработан алгоритм формирования представления analysis.orders - src/task2

